using System.Data;
using System.Xml;
using LookaheadsTable = System.Collections.Generic.Dictionary<
    System.Collections.Generic.HashSet<LrZeroAutomata.Item>,
    System.Collections.Generic.Dictionary<
        LrZeroAutomata.Item,
        (System.Collections.Generic.HashSet<string> spontaneous,
            System.Collections.Generic.HashSet<
                (System.Collections.Generic.HashSet<LrZeroAutomata.Item>,
                    LrZeroAutomata.Item
                )
            > propagated
        )
    >
>;

internal sealed class LalrOneAutomata
{
    public record struct Item(Production Production, int Dot, string Lookahead);

    private readonly Grammar _grammar;
    private readonly LrZeroAutomata _lrZero;

    public LalrOneAutomata(Grammar grammar, LrZeroAutomata automata)
    {
        _grammar = grammar;
        _lrZero = automata;
    }

    // TODO: handle productions containing epsilon
    private IEnumerable<string> First(params string[] symbols)
    {
        bool allHaveEpsilon = true;
        foreach (var symbol in symbols)
        {
            bool hasEpsilon = false;
            foreach (var first in First(symbol))
            {
                if (first == "")
                {
                    hasEpsilon = true;
                    continue;
                }

                yield return first;
            }

            if (!hasEpsilon)
            {
                allHaveEpsilon = false;
                break;
            }
        }

        if (allHaveEpsilon)
            yield return "";
    }

    private IEnumerable<string> First(string symbol)
    {
        var rule = _grammar.GetRuleByName(symbol);

        if (rule == null)
        {
            // This is a terminal.
            yield return symbol;
            yield break;
        }

        bool allHaveEpsilon = true;
        foreach (var production in rule.Productions)
        {
            bool hasEpsilon = false;
            foreach (var nextSymbol in production.Symbols)
            {
                if (nextSymbol == "")
                {
                    hasEpsilon = true;
                    continue;
                }

                yield return nextSymbol;
            }

            if (!hasEpsilon)
            {
                allHaveEpsilon = false;
                break;
            }
        }

        if (allHaveEpsilon)
            yield return "";
    }

    private HashSet<Item> Closure(HashSet<Item> items)
    {
        var added = new HashSet<Item>();

        do
        {
            added.Clear();

            foreach (var item in items)
            {
                // Dot is on the RHS, so there is nothing following it
                if (item.Dot == item.Production.Symbols.Length)
                    continue;

                var symbol = item.Production.Symbols[item.Dot];
                var rule = _grammar.GetRuleByName(symbol);

                // Symbol is a terminal, so we ignore it.
                if (rule is not null)
                    continue;

                var nextSymbols = item.Production.Symbols
                    .Skip(item.Dot + 1)
                    .Append(item.Lookahead)
                    .ToArray();

                foreach (var terminal in First(nextSymbols))
                {
                    if (terminal != "")
                    {
                        var newItem = new Item(item.Production, 0, terminal);
                        if (!items.Contains(newItem))
                            _ = added.Add(newItem);
                    }
                }
            }

            foreach (var add in added)
                _ = items.Add(add);
        }
        while (added.Count > 0);

        return items;
    }

    private HashSet<Item> ComputeGoto(HashSet<Item> items, string symbol)
    {
        var result = new HashSet<Item>();
        foreach (var item in items)
        {
            if (item.Dot == item.Production.Symbols.Length)
                continue;

            _ = result.Add(new(item.Production, item.Dot + 1, item.Lookahead));
        }

        return Closure(result);
    }

    public void ComputeKernels()
    {
        // Step 1
        var kernels = _lrZero.Items
            .Select(x => _lrZero.Kernel(x))
            .ToList();

        // Step 2, 3
        var table = new LookaheadsTable(LrZeroAutomata.SetOfSetComparer.Instance);

        int index = 0;
        foreach (var kernel in kernels)
        {
            var currentIndex = index++;

            var set = new Dictionary<LrZeroAutomata.Item, (HashSet<string>, HashSet<(HashSet<LrZeroAutomata.Item>, LrZeroAutomata.Item)>)>();
            table.Add(kernel, set);

            foreach (var item in kernel)
            {
                var lookaheads = new HashSet<string>();
                var propagatesTo = new HashSet<(HashSet<LrZeroAutomata.Item>, LrZeroAutomata.Item)>();
                var closure = Closure(GenerateLalrItem(item));

                set.Add(item, (lookaheads, propagatesTo));

                foreach (var symbol in _grammar.Symbols)
                {
                    if (_lrZero.TryGetGoto(currentIndex, symbol, out var destination))
                    {
                        var destinationState = _lrZero.Kernel(_lrZero.Items[destination]);
                        foreach (var lalrItem in closure)
                        {
                            if (lalrItem.Dot == lalrItem.Production.Symbols.Length
                                || symbol != lalrItem.Production.Symbols[lalrItem.Dot])
                                continue;
                            
                            if (lalrItem.Lookahead == "LOOKAHEAD")
                            {
                                _ = propagatesTo.Add((destinationState,
                                    new(lalrItem.Production, lalrItem.Dot + 1)));
                            }
                            else
                            {
                                _ = lookaheads.Add(lalrItem.Lookahead);
                            }
                        }
                    }
                }
            }
        }

        // Step 4
        bool changed = false;
        do
        {
            foreach (var pair in table)
            {
                foreach (var pair2 in pair.Value)
                {
                    foreach (var propagate in pair2.Value.propagated)
                    {
                        var (spontaneous, _) = table[propagate.Item1][propagate.Item2];

                        var original = spontaneous.Count;
                        spontaneous.UnionWith(pair2.Value.spontaneous);
                        if (spontaneous.Count != original)
                            changed = true;
                    }
                }
            }
        }
        while (changed);

        Console.WriteLine("WOOHOO");

        static HashSet<Item> GenerateLalrItem(LrZeroAutomata.Item item)
        {
            var result = new HashSet<Item>
            {
                new Item(item.Production, item.Dot, "LOOKAHEAD")
            };

            return result;
        }
    }
}